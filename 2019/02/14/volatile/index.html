<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>从计算机角度理解volatile | 果粒写字的地方</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">从计算机角度理解volatile</h1><a id="logo" href="/.">果粒写字的地方</a><p class="description">要成为一名优秀的工程师</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">从计算机角度理解volatile</h1><div class="post-meta">Feb 14, 2019<span> | </span><span class="category"><a href="/categories/并发/">并发</a></span></div><a class="disqus-comment-count" data-disqus-identifier="2019/02/14/volatile/" href="/2019/02/14/volatile/#disqus_thread"></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU硬件架构"><span class="toc-number">1.</span> <span class="toc-text">CPU硬件架构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#基本概念"><span class="toc-number">1.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MESI协议"><span class="toc-number">1.2.</span> <span class="toc-text">MESI协议</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java内存模型简介"><span class="toc-number">2.</span> <span class="toc-text">Java内存模型简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java内存模型和硬件内存架构之间的关系"><span class="toc-number">3.</span> <span class="toc-text">Java内存模型和硬件内存架构之间的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JMM的三个基本概念"><span class="toc-number">4.</span> <span class="toc-text">JMM的三个基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#原子性"><span class="toc-number">4.1.</span> <span class="toc-text">原子性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#有序性"><span class="toc-number">4.2.</span> <span class="toc-text">有序性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#可见性"><span class="toc-number">4.3.</span> <span class="toc-text">可见性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JMM提供的解决方案"><span class="toc-number">5.</span> <span class="toc-text">JMM提供的解决方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile的语义"><span class="toc-number">6.</span> <span class="toc-text">volatile的语义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#可见性保证"><span class="toc-number">6.1.</span> <span class="toc-text">可见性保证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#禁止指令重排序"><span class="toc-number">6.2.</span> <span class="toc-text">禁止指令重排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile原子性"><span class="toc-number">6.3.</span> <span class="toc-text">volatile原子性</span></a></li></ol></li></ol></div></div><div class="post-content"><p>volatile是进行多线程编程时常用到的一个关键字，在阅读过众多他人的博客以及相应的文章之后，对volatile有了一个更加详细的认知，下面将从多个角度来分析volatile到底是怎么起作用的。</p>
<h3 id="CPU硬件架构"><a href="#CPU硬件架构" class="headerlink" title="CPU硬件架构"></a>CPU硬件架构</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>当一个程序在运行的时候，其实是CPU在不断的执行机器指令，执行的时候免不了要和数据打交道。程序运行时所需要的数据是在主存里面的，也就是计算机的物理内存，在一开始的时候还相安无事。但是随着CPU的不断发展，CPU的执行速度越来越快，内存技术却没有太大的变化，所以从内存中读取以及写入数据的过程和CPU的执行速度之间的差距就越来越大，这就导致CPU在很长一段时间内是处于空着的状态，每次操作内存都需要花费大量的时间在等待上面。然而高速缓存的问世就比较好的解决了这个问题，在CPU和主存之间加入一层缓存，当程序运行的时候，会将需要的数据从主存复制一份到CPU的高速缓存中，CPU进行计算的时候就可以直接从它的缓存中读取和写入数据，当运算结束后再将高速缓存中的数据刷新到主存当中。当今主流的CPU内部的缓存架构如下图所示</p>
<p><img src="/2019/02/14/volatile/cpuframework.png"></p>
<p>从上面的架构图我们不难发现，如果是单核心的CPU，读写操作都是单核完成，这没什么问题，但是多核心架构的话，就会存在一些意想不到的状况，如：一个核心修改某个变量A的值之后，由于其他核心中的缓存还存放的是未被修改时A的值，继续拿来使用便会造成数据不一致的结果。</p>
<h4 id="MESI协议"><a href="#MESI协议" class="headerlink" title="MESI协议"></a>MESI协议</h4><p>在早期的CPU当中，是通过对总线加上LOCK#锁的形式来解决缓存不一致的问题，因为CPU和内存的交互都是通过总线进行的，如果对总线加上锁的话，相当于阻塞了其他CPU对内存的访问，从而使得某一时刻只有一个CPU能使用这个变量的内存，这样就解决了缓存不一致的问题。但是这样的方式在锁住总线期间，其他CPU无法访问内存，导致效率低下。所以就出现了缓存一致性协议，最出名的就是Intel的MESI协议了，该协议能保证每个CPU的高速缓存中所使用的共享变量的副本是一致的。它的核心思想是：当CPU写数据的时候，如果发现操作的变量是共享变量(即在其他CPU中也存在该变量的副本，那么便会发出信号通知其他CPU将该变量置为无效状态，因此当其他CPU需要读取这个变量的时候，发现自己缓存中的该变量的缓存行是无效的，那么它就会重新从内存中读取)。</p>
<p><img src="/2019/02/14/volatile/mesi.jpg"></p>
<h3 id="Java内存模型简介"><a href="#Java内存模型简介" class="headerlink" title="Java内存模型简介"></a>Java内存模型简介</h3><p>Java内存模型(即Java Memory Model，简称JMM)本身是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量的访问方式。jvm运行程序的实体是线程，而每个线程创建的时候jvm都会为其创建一个工作内存用于存储线程的私有数据，而Java内存模型规定所有的变量都存储在主内存(共享内存区域)，所有线程都可以访问，但是线程对变量的操作必须的该线程的工作内存中进行，首先要将变量从主内存拷贝自己的工作内存空间，然后对变量进行操作，操作完成后再写回主内存。因此不同的线程无法访问对方的工作内存，线程之间的通信必须通过主内存来完成。</p>
<p><img src="/2019/02/14/volatile/jmm.png"></p>
<p>需要注意的一点是，JMM和Java内存区域的划分是不同层次的概念，更恰当的说JMM描述的是一组规则，通过这组规则控制程序中的各个变量在共享数据区域和私有数据区域的访问方式，JMM是围绕原子性，有序性和可见性展开的。</p>
<h3 id="Java内存模型和硬件内存架构之间的关系"><a href="#Java内存模型和硬件内存架构之间的关系" class="headerlink" title="Java内存模型和硬件内存架构之间的关系"></a>Java内存模型和硬件内存架构之间的关系</h3><p>Java的线程是和操作系统内核线程一一对应的，多线程的执行最终还是会映射到硬件处理器上进行执行，但从上面的介绍来看，Java内存模型和硬件内存架构并不完全一致。对于硬件上来说，只有寄存器，缓存，主内存的概念，并没有什么工作内存和主内存之分，也就是说Java内存模型对内存的划分对硬件内存并没有任何影响。JMM只是一个抽象的概念，是一组规则，并不是实际存在的，不管是工作内存的数据还是主内存的数据，对于计算机硬件来说都会存储到计算机的主内存中，当然也有可能存储到CPU缓存或者寄存器中。因此总体上来说，Java内存模型和计算机硬件内存架构是一个相互交叉的关系，是一种抽象概念划分和真实物理硬件的交叉。（参考：<a href="http://tutorials.jenkov.com/java-concurrency/java-memory-model.html）" target="_blank" rel="noopener">http://tutorials.jenkov.com/java-concurrency/java-memory-model.html）</a></p>
<p><img src="/2019/02/14/volatile/jmm2cpu.png"></p>
<h3 id="JMM的三个基本概念"><a href="#JMM的三个基本概念" class="headerlink" title="JMM的三个基本概念"></a>JMM的三个基本概念</h3><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>原子性指的是一个操作是不可中断的，即使是在多线程环境下，一个操作一旦开始就不会被其他线程影响。</p>
<h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>在计算机执行程序的时候，为了提高性能，编译器和处理器常常会对指令进行重排序。</p>
<ul>
<li>编译器优化重排序</li>
</ul>
<p>编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序</p>
<ul>
<li>指令并行的重排序</li>
</ul>
<p>现代处理器采用了指令级别的并行技术来将多条指令并行执行，如果不存在数据的依赖性，处理器可以改变语句对应的机器执行的执行顺序</p>
<ul>
<li>内存系统的重排序</li>
</ul>
<p>由于处理器使用缓存和读写缓存冲区，这使得加载(load)和存储(store)操作看上去可能是在乱序执行，因为三级缓存的存在，导致内存与缓存的数据同步存在时间差。</p>
<p>其中编译器优化的重排属于编译期重排，指令并行的重排和内存系统的重排属于处理器重排，在多线程环境中，这些重排优化可能会导致程序出现内存可见性问题。对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序。对于处理器重排序，JMM的编译器重排序规则会要求Java编译器在生成指令序列时，插入特定类型的内存屏障指令，通过内存屏障来禁止特定类型的处理器重排序。JMM属于语言级别的内存模型，它确保在不同的编译器会不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</p>
<h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>解释完指令重排序现象之后，可见性就非常容易理解了。可见性指的是当一个线程修改了某个共享变量的值，其他线程是否能够马上得知这个值的修改。</p>
<h3 id="JMM提供的解决方案"><a href="#JMM提供的解决方案" class="headerlink" title="JMM提供的解决方案"></a>JMM提供的解决方案</h3><p>上述三个问题，JMM都有相应的解决方案提供给出程序员使用。如原子性的问题，除了jvm自身提供的对基本数据类型读写操作的原子性之外，对于方法级别或者代码块级别的原子性操作，可以使用synchronized关键字或者可重入锁ReentrantLock来保证程序执行的原子性。而工作内存与主内存同步延迟现象导致的可见性问题，可以使用synchronized关键字或者volatile关键字来解决，这两个关键字都可以使一个线程修改后的变量立即对其他线程可见。对于指令重排序的问题，则可以使用volatile来解决，因为volatile的另外一个作用便是禁止重排序优化。除了靠synchronized和volatile关键字来保证原子性，可见性和有序性之外，JMM内部还定义了一套happens-before原则来保证多线程环境下两个操作的原子性，可见性和有序性。</p>
<h3 id="volatile的语义"><a href="#volatile的语义" class="headerlink" title="volatile的语义"></a>volatile的语义</h3><p>volatile是Java虚拟机提供的轻量级同步机制，其两个作用如下：</p>
<ul>
<li>保证被volatile修饰的共享变量对所有线程总是可见的，也就是当一个线程修改了一个被volatile修饰的共享变量的值，新值总是可以被其他线程立刻得知</li>
<li>禁止指令重排序的优化</li>
</ul>
<h4 id="可见性保证"><a href="#可见性保证" class="headerlink" title="可见性保证"></a>可见性保证</h4><p>被volatile修饰的变量，在转变成汇编代码的时候，会多出一个LOCK#前缀的指令，这个指令在多核CPU架构下会引发两件事情</p>
<ul>
<li>将当前处理器缓存行的数据写回到系统内存中</li>
<li>这个写回的操作会使在其他CPU中缓存了该内存地址的数据实效</li>
</ul>
<p>所以我们不难发现，volatile的底层实现其实就是借助了CPU的缓存一致性协议。后续众多的多线程并发解决方案都是通过volatile+cas原子操作来实现的。</p>
<h4 id="禁止指令重排序"><a href="#禁止指令重排序" class="headerlink" title="禁止指令重排序"></a>禁止指令重排序</h4><p>volatile关键字另一个作用就是禁止指令重排优化，从而避免多线程环境下程序出现乱序执行的现象，具体如何禁止的，其实是在转换成汇编代码的时候，在volatile变量的前后根据一些条件来插入特定的内存屏障，来告诉编译器和处理器，这些指令我不需要重排序，这里就不再详细展开了。</p>
<h4 id="volatile原子性"><a href="#volatile原子性" class="headerlink" title="volatile原子性"></a>volatile原子性</h4><p>对于单个volatile变量的读写具有原子性，但类似于volatile++这种复合操作则不具备原子性(i++这种操作转换成汇编并不是一条指令就能完成的)</p>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2019/02/14/templateAndstrategy/">模板方法模式&amp;策略模式</a><a class="next" href="/2019/01/26/snowflake/">分布式ID生成策略</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'http://yoursite.com/2019/02/14/volatile/';
    this.page.identifier = '2019/02/14/volatile/';
    this.page.title = '从计算机角度理解volatile';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//qiang.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//qiang.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://qiang.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });
</script></div><div id="uyan_frame"></div><script type="text/javascript" src="//v2.uyan.cc/code/uyan.js?uid=160717"></script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/分布式/">分布式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/并发/">并发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/03/28/future/">Future接口</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/28/redisnote/">redis学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/28/haxi/">一致性哈希</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/28/bloomfilter/">布隆过滤器</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/28/skiplist/">跳表</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/03/redissync/">redis实现分布式锁</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/25/proxyAnddecorator/">代理模式&装饰器模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/24/ReentrantLock/">ReentrantLock以及AQS实现原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/14/templateAndstrategy/">模板方法模式&策略模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/14/volatile/">从计算机角度理解volatile</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://mrdear.cn/" title="屈定's Blog - change from today" target="_blank">屈定's Blog - change from today</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">果粒写字的地方.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>