<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>ReentrantLock以及AQS实现原理 | 果粒写字的地方</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">ReentrantLock以及AQS实现原理</h1><a id="logo" href="/.">果粒写字的地方</a><p class="description">要成为一名优秀的工程师</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">ReentrantLock以及AQS实现原理</h1><div class="post-meta">Feb 24, 2019<span> | </span><span class="category"><a href="/categories/并发/">并发</a></span></div><a class="disqus-comment-count" data-disqus-identifier="2019/02/24/ReentrantLock/" href="/2019/02/24/ReentrantLock/#disqus_thread"></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantLock锁的架构"><span class="toc-number">1.</span> <span class="toc-text">ReentrantLock锁的架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS同步队列"><span class="toc-number">2.</span> <span class="toc-text">AQS同步队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基于AQS分析ReetrantLock独占锁模式的实现"><span class="toc-number">3.</span> <span class="toc-text">基于AQS分析ReetrantLock独占锁模式的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#初始化"><span class="toc-number">3.1.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#加锁操作"><span class="toc-number">3.2.</span> <span class="toc-text">加锁操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#入同步队列"><span class="toc-number">3.3.</span> <span class="toc-text">入同步队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#自旋"><span class="toc-number">3.4.</span> <span class="toc-text">自旋</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实例"><span class="toc-number">3.5.</span> <span class="toc-text">实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#释放锁操作"><span class="toc-number">3.6.</span> <span class="toc-text">释放锁操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReetrantLock中的公平锁"><span class="toc-number">4.</span> <span class="toc-text">ReetrantLock中的公平锁</span></a></li></ol></div></div><div class="post-content"><p>提到Java中的锁，我们可能第一时间想到的是Synchronized，今天来详细分析下ReentrantLock。ReentrantLock顾名思义可重入锁，就是支持重进入的锁，它表示该锁能够支持一个线程对资源的重复加锁。除此之外，该锁还支持获取锁时的公平和非公平性选择。针对可重入锁的具体实现，需要从它的一个内部类Sync说起，Sync的父类是AbstractQueuedSynchronizer(简称AQS)。</p>
<h3 id="ReentrantLock锁的架构"><a href="#ReentrantLock锁的架构" class="headerlink" title="ReentrantLock锁的架构"></a>ReentrantLock锁的架构</h3><p>ReentrantLock锁的架构相对来说比较简单，主要包括一个Sync内部抽象类以及Sync抽象类的两个实现类，结构示意图如下所示。</p>
<p><img src="/2019/02/24/ReentrantLock/ReentrantLock.png"></p>
<p>AQS的父类AbstractOwnableSynchronizer(下面简称AOS)，它主要提供一个exclusiveOwnerThread属性，用于关联当前持有锁的线程，另外Sync的两个实现类从名字我们可以知道一个用于公平锁，一个用于非公平锁。下面是ReentrantLock的一些核心方法。</p>
<p><img src="/2019/02/24/ReentrantLock/lock.png"></p>
<p>默认构造函数构造的是非公平锁，可通过一个布尔值来控制，具体的lock方法调用的是sync的lock，整体的结构看起来还是比较简单。FairSync和NonFairSync都继承自Sync，Sync继承自AQS，AQS是采用模板方法的设计模式，它作为基础并发组件，封装了一层核心并发操作(比如获取资源成功后封装成Node加入队列，对队列双向链表的处理)，接下来我们来详细看看AQS的工作原理。</p>
<h3 id="AQS同步队列"><a href="#AQS同步队列" class="headerlink" title="AQS同步队列"></a>AQS同步队列</h3><p>先来瞅瞅AQS中非常重要的几个字段以及相应的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 同步队列节点</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 指向同步队列队头</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 指向同步队列队尾</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 同步状态字段,0代表未被占用,1代表已被占用,核心字段</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">        state = newState;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>节点类，指向队头的head，指向队尾的tail，同步状态等字段构成了AQS，再来看看这个Node内部类，它是对每一个访问同步代码块的线程的封装，下面是同步队列的基本结构。</p>
<p><img src="/2019/02/24/ReentrantLock/aqs.png"></p>
<ul>
<li>AQS内部有一个Node组成的同步队列，它是双向链表结构</li>
<li>AQS内部通过state来控制同步状态，当执行到lock时，如果state=0，说明没有任何线程占有共享资源的锁，此时线程会获取到锁并把state设置为1，当state=1时，则说明有线程目前正在使用共享变量，其他线程必须加入同步队列进行等待。</li>
</ul>
<p>AQS内部又分为共享模式和独占模式，无论是共享模式还是独占模式，都维持着一个虚拟的同步队列，当请求锁的线程超过现有模式的限制时，会将线程包装成Node节点并将线程当前必要的信息存储到Node节点中，然后加入同步队列，这一系列的操作封装在AQS中，这也是它会作为一个基础组件的原因，Java中一系列的并发操作的基础都是该类。</p>
<h3 id="基于AQS分析ReetrantLock独占锁模式的实现"><a href="#基于AQS分析ReetrantLock独占锁模式的实现" class="headerlink" title="基于AQS分析ReetrantLock独占锁模式的实现"></a>基于AQS分析ReetrantLock独占锁模式的实现</h3><p>ReetrantLock分为公平锁以及非公平锁，下面直接从非公平锁的角度来分析。</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认构造函数，构造非公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据传入参数创建锁类型</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加锁操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认构建非公平锁(关于公平锁与非公平锁的比较后面会再次提到)，同时可以通过参数来构建公平锁。</p>
<h4 id="加锁操作"><a href="#加锁操作" class="headerlink" title="加锁操作"></a>加锁操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非公平锁实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//执行CAS操作，本质就是CAS更新state：</span></span><br><span class="line">        <span class="comment">//判断state是否为0，如果为0则把0更新为1，并返回true否则返回false</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">           <span class="comment">//成功则将独占锁线程设置为当前线程  </span></span><br><span class="line">          setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//否则再次请求同步状态</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，通过CAS机制保证并发的情况下只有一个线程可以成功将state设置为1进而获取到锁，其他线程在执行cas的时候发现state不等于0进而执行acquire(1)。</p>
<h4 id="入同步队列"><a href="#入同步队列" class="headerlink" title="入同步队列"></a>入同步队列</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//再次尝试获取同步状态</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里传入的arg是state的值，因为要获取锁，state为0的时候是释放锁，所以这里传入的值为1 ，进入方法后会先执行tryAcquire方法(1)方法，该方法是由ReetrantLock类的内部类实现的，具体如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NonfairSync类</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="comment">// 获取volatile类型的state</span></span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/** 这里便是非公平锁的实现，state为0表示这个时刻没有其他线程获取锁</span></span><br><span class="line"><span class="comment">             *  此时不管队列的顺序，只要有线程获取锁失败则会执行cas操作再次尝试获取一次</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里表示获取锁的线程是Owner，也就是重入锁重复加锁的情况，这时state会再加1</span></span><br><span class="line">        <span class="comment">// 因为是同一个线程，所以不会有线程安全的问题</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>仔细看源代码我们会知道，公平锁的tryAcquire是在其子类FairSync中实现的，那为什么非公平锁的实现需要提到父类中去实现呢？</p>
<p>因为ReetrantLock还实现了Lock接口，在Lock接口的语义里，tryLock()是不分公平与非公平的，（实际语义其实等同于非公平的）所以初始构造ReentrantLock时候，无论是new的fairSync还是notfairSync，都应该可以执行tryLock()，因此tryLock()用到的Sync(AQS)的nonfairTryAcquire()，应该在NonfairSync,FairSync父类中实现，就是此类Sync，这样才可以达到共用的效果。</p>
<p>假设有三个线程：线程1已经获得了锁，线程2正在同步队列中排队，此时线程3执行lock方法尝试获取锁时，线程1正好释放了锁，将state更新为0，那么线程3就可能在线程2还没有被唤醒之前获取到这个锁。</p>
<p>如果此时还没有获取到锁(nonfairTryAcquire返回false)，那么接下来会把该线程封装成Node对象去同步队列里排队，代码层面上是执行acquireQueued(addWaiter(Node.EXCLUSIVE), arg)，传入Node.EXCLUSIVE表示该锁是独占锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将请求同步状态失败的线程封装成结点</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line"></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="comment">//如果是第一个结点加入肯定为空，跳过。</span></span><br><span class="line">    <span class="comment">//如果非第一个结点则直接执行CAS入队操作，尝试在尾部快速添加</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">//使用CAS执行尾部结点替换，尝试在尾部快速添加</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果第一次加入或者CAS操作没有成功执行enq入队操作</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果第一次获取到锁，AQS还没有初始化，则tail为空，那么将执行enq(node)操作，如果非第一个节点，直接尝试使用cas操作加入队尾，如果cas操作失败或者说是第一次加入同步队列还是会执行enq(node)，继续看enq(node)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//死循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">         Node t = tail;</span><br><span class="line">         <span class="comment">//如果队列为null，即没有头结点</span></span><br><span class="line">         <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">             <span class="comment">//创建并使用CAS设置头结点</span></span><br><span class="line">             <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                 tail = head;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;<span class="comment">//队尾添加新结点</span></span><br><span class="line">             node.prev = t;</span><br><span class="line">             <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                 t.next = node;</span><br><span class="line">                 <span class="keyword">return</span> t;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法采用一个死循环进行cas操作，可以很好的解决多线程并发的问题。这里主要做了两件事情，一是队列不存在则创建新的头节点并初始化tail，head(使用compareAndSetHead来设置头节点，然后再对tail进行赋值)，二是队列已经存在，则将新节点添加到队尾。</p>
<p>这里我们可以看到，addWaiter和enq中存在着相同的代码，都是将线程设置为同步队列的队尾，这是因为，在多线程的状态下，假设线程1，2，3，4同时执行到了addWaiter方法，并且头节点还未初始化，那么线程2，3，4(并不绝对)执行cas的时候都会失败，此刻线程2，3，4会在enq这个方法内部进行死循环执行cas操作，直到成功添加到队尾为止，这也就意味着enq方法内部还需执行三次循环，这也同样就保证了所有线程都能成功的入队列。</p>
<h4 id="自旋"><a href="#自旋" class="headerlink" title="自旋"></a>自旋</h4><p>回到之前的acquire()方法中，在把节点添加到同步队列之后，会继续执行acquireQueued方法，这个方法起到一个自旋的作用即节点在观察时机准备获取同步状态，下面来看acquireQueued方法具体是怎么实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取前结点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 当且仅当p为头结点才尝试获取同步状态,FIFO</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">// 此时当前node前驱节点为head且已经tryAcquire获取到了锁，正在执行了它的相关信息</span></span><br><span class="line">                <span class="comment">// 已经没有任何用处了，所以现在需要考虑将它GC掉</span></span><br><span class="line">                <span class="comment">// 将node设置为头结点</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                <span class="comment">// 清空原来头结点的引用便于GC</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果前驱结点不是head，判断是否挂起线程</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;       </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            <span class="comment">// 最终都没能获取同步状态，结束该线程的请求</span></span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个死循环中，如果满足了条件if (p == head &amp;&amp; tryAcquire(arg))，即当前节点的前驱节点为head并且通过tryAcquire获得了锁，把当前节点设置为头节点，清空原来头节点的引用，方便进行GC操作(真是厉害)。如果前驱节点不是head或者此时还是没有获取到锁，那么走下面的逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;parkAndCheckInterrupt())</span><br><span class="line">      interrupted = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前结点的等待状态</span></span><br><span class="line">        <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">        <span class="comment">// 如果为等待唤醒（SIGNAL）状态则返回true</span></span><br><span class="line">        <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 如果ws&gt;0 则说明是结束状态，</span></span><br><span class="line">        <span class="comment">// 遍历前驱结点直到找到没有结束状态的结点</span></span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">            pred.next = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果ws小于0又不是SIGNAL状态，</span></span><br><span class="line">            <span class="comment">// 则将其设置为SIGNAL状态，代表该结点的线程正在等待唤醒。</span></span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码的设计也是非常的精髓，通常设计队列的时候应该要考虑的是如何最大化饿减少后续排队节点对于CPU的消耗，而在AQS中，只要当前节点的前驱节点不是头节点，再把当前节点加到队列后就会执行LockSupport.park()，将当前线程挂起，这样可以最大化的减少CPU的消耗。</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>假设ABC三个线程同时获取锁</p>
<ul>
<li><p>A首先获得锁:</p>
<p>ReetranLock.lock()-&gt;compareAndSetState(0,1)-&gt;setExclusiveOwnerThread(Thread.currentThread())</p>
<p>此时AQS结构尚未初始化</p>
<p><img src="/2019/02/24/ReentrantLock/A.png"></p>
</li>
<li><p>B线程尝试获取锁</p>
<p>因为此时state的状态还为1(假设A线程暂时未释放锁)，所以线程B获取失败，进行入队列操作，入队列时发现tail未null，还未初始化，进入enq方法逻辑中执行死循环中的逻辑，第一次循环先初始化一个节点</p>
<p><img src="/2019/02/24/ReentrantLock/new.png"></p>
<p>初始化完成，进行第二次循环。将B节点的前置节点置为tail，然后把tail指向当前节点</p>
<p><img src="/2019/02/24/ReentrantLock/B.png"></p>
<p>入队列完成后会继续进入acquireQueued方法，第一次进行循环的时候发现自己的前序节点是head，于是乎再次尝试获取锁，失败后再进入shouldParkAfterFailedAcquire逻辑，把前序节点的状态设置为Singal状态。第二次进行循环的时候，再次尝试获取锁，但因为前序节点已经是Signal状态了，所以执行parkAndCheckInterrupt把自己休眠起来进行自旋。</p>
<p><img src="/2019/02/24/ReentrantLock/zixuan.png"></p>
</li>
<li><p>C线程尝试获取锁</p>
<p>C线程获取锁和B线程一样，不同的是它的前序节点不是head而是B，所以他不会一直尝试获取锁，只会待在后面park住。</p>
<p><img src="/2019/02/24/ReentrantLock/C.png"></p>
</li>
</ul>
<p>由上面过程的分析，我们可以得出以下结论，AQS结构其实是在第二个线程获取锁的时候再初始化的，就是lazy-init的思想，最大程度的减少代码执行的开销。同时为了避免CPU上下文切换的耗时，在设计排队线程的时候，只有头节点的下一个线程一直在重复的获取锁，队列后面的线程会通过LockSupport进行休眠。</p>
<h4 id="释放锁操作"><a href="#释放锁操作" class="headerlink" title="释放锁操作"></a>释放锁操作</h4><p>直接来看代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ReentrantLock类的unlock</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AQS类的release()方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//尝试释放锁</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//唤醒后继结点的线程</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ReentrantLock类中的内部类Sync实现的tryRelease(int releases) </span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">      <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">      <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">      <span class="comment">//判断状态是否为0，如果是则说明已释放同步状态</span></span><br><span class="line">      <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">          free = <span class="keyword">true</span>;</span><br><span class="line">          <span class="comment">//设置Owner为null</span></span><br><span class="line">          setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//设置更新同步状态</span></span><br><span class="line">      setState(c);</span><br><span class="line">      <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一言以蔽之，锁的释放过程，其实就是先把volatile类型的变量state减1，state从1变成0，unparkSuccessor的作用为唤醒后续节点，后续节点被唤醒后会继续进入acquireQueued函数的if (p == head &amp;&amp; tryAcquire(arg))的判断，然后把自己设置为head节点，表示自己已经获取到资源，最终acquire也返回了，这就是独占锁的释放过程。</p>
<h3 id="ReetrantLock中的公平锁"><a href="#ReetrantLock中的公平锁" class="headerlink" title="ReetrantLock中的公平锁"></a>ReetrantLock中的公平锁</h3><p>从加锁的方法上来看，唯一的区别就是多了一个hasQueuedPredecessors的判断，这就是公平锁和非公平锁最大的区别。在公平锁中，当线程请求到来时会先判断同步队列是否存在节点，如果存在先执行同步队列中的节点线程，而非公平锁当线程请求到来时，不管同步队列是否存在线程节点，直接上去尝试获取同步状态，获取成功直接访问共享资源。</p>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2019/02/25/proxyAnddecorator/">代理模式&amp;装饰器模式</a><a class="next" href="/2019/02/14/templateAndstrategy/">模板方法模式&amp;策略模式</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'http://yoursite.com/2019/02/24/ReentrantLock/';
    this.page.identifier = '2019/02/24/ReentrantLock/';
    this.page.title = 'ReentrantLock以及AQS实现原理';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//qiang.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//qiang.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://qiang.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });
</script></div><div id="uyan_frame"></div><script type="text/javascript" src="//v2.uyan.cc/code/uyan.js?uid=160717"></script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/分布式/">分布式</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/并发/">并发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/03/28/future/">Future接口</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/28/redisnote/">redis学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/28/haxi/">一致性哈希</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/28/bloomfilter/">布隆过滤器</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/28/skiplist/">跳表</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/03/redissync/">redis实现分布式锁</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/25/proxyAnddecorator/">代理模式&装饰器模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/24/ReentrantLock/">ReentrantLock以及AQS实现原理</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/14/templateAndstrategy/">模板方法模式&策略模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/14/volatile/">从计算机角度理解volatile</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://mrdear.cn/" title="屈定's Blog - change from today" target="_blank">屈定's Blog - change from today</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">果粒写字的地方.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>