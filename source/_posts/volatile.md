---
title: 从计算机角度理解volatile
date: 2019-02-14 14:05:30
categories: 并发
toc: true
---

volatile是进行多线程编程时常用到的一个关键字，在阅读过众多他人的博客以及相应的文章之后，对volatile有了一个更加详细的认知，下面将从多个角度来分析volatile到底是怎么起作用的。

### CPU硬件架构

#### 基本概念

当一个程序在运行的时候，其实是CPU在不断的执行机器指令，执行的时候免不了要和数据打交道。程序运行时所需要的数据是在主存里面的，也就是计算机的物理内存，在一开始的时候还相安无事。但是随着CPU的不断发展，CPU的执行速度越来越快，内存技术却没有太大的变化，所以从内存中读取以及写入数据的过程和CPU的执行速度之间的差距就越来越大，这就导致CPU在很长一段时间内是处于空着的状态，每次操作内存都需要花费大量的时间在等待上面。然而高速缓存的问世就比较好的解决了这个问题，在CPU和主存之间加入一层缓存，当程序运行的时候，会将需要的数据从主存复制一份到CPU的高速缓存中，CPU进行计算的时候就可以直接从它的缓存中读取和写入数据，当运算结束后再将高速缓存中的数据刷新到主存当中。当今主流的CPU内部的缓存架构如下图所示

<img src="cpuframework.png">

从上面的架构图我们不难发现，如果是单核心的CPU，读写操作都是单核完成，这没什么问题，但是多核心架构的话，就会存在一些意想不到的状况，如：一个核心修改某个变量A的值之后，由于其他核心中的缓存还存放的是未被修改时A的值，继续拿来使用便会造成数据不一致的结果。

#### MESI协议

在早期的CPU当中，是通过对总线加上LOCK#锁的形式来解决缓存不一致的问题，因为CPU和内存的交互都是通过总线进行的，如果对总线加上锁的话，相当于阻塞了其他CPU对内存的访问，从而使得某一时刻只有一个CPU能使用这个变量的内存，这样就解决了缓存不一致的问题。但是这样的方式在锁住总线期间，其他CPU无法访问内存，导致效率低下。所以就出现了缓存一致性协议，最出名的就是Intel的MESI协议了，该协议能保证每个CPU的高速缓存中所使用的共享变量的副本是一致的。它的核心思想是：当CPU写数据的时候，如果发现操作的变量是共享变量(即在其他CPU中也存在该变量的副本，那么便会发出信号通知其他CPU将该变量置为无效状态，因此当其他CPU需要读取这个变量的时候，发现自己缓存中的该变量的缓存行是无效的，那么它就会重新从内存中读取)。

<img src="mesi.jpg">

### Java内存模型简介

Java内存模型(即Java Memory Model，简称JMM)本身是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量的访问方式。jvm运行程序的实体是线程，而每个线程创建的时候jvm都会为其创建一个工作内存用于存储线程的私有数据，而Java内存模型规定所有的变量都存储在主内存(共享内存区域)，所有线程都可以访问，但是线程对变量的操作必须的该线程的工作内存中进行，首先要将变量从主内存拷贝自己的工作内存空间，然后对变量进行操作，操作完成后再写回主内存。因此不同的线程无法访问对方的工作内存，线程之间的通信必须通过主内存来完成。

<img src="jmm.png">

需要注意的一点是，JMM和Java内存区域的划分是不同层次的概念，更恰当的说JMM描述的是一组规则，通过这组规则控制程序中的各个变量在共享数据区域和私有数据区域的访问方式，JMM是围绕原子性，有序性和可见性展开的。

### Java内存模型和硬件内存架构之间的关系

Java的线程是和操作系统内核线程一一对应的，多线程的执行最终还是会映射到硬件处理器上进行执行，但从上面的介绍来看，Java内存模型和硬件内存架构并不完全一致。对于硬件上来说，只有寄存器，缓存，主内存的概念，并没有什么工作内存和主内存之分，也就是说Java内存模型对内存的划分对硬件内存并没有任何影响。JMM只是一个抽象的概念，是一组规则，并不是实际存在的，不管是工作内存的数据还是主内存的数据，对于计算机硬件来说都会存储到计算机的主内存中，当然也有可能存储到CPU缓存或者寄存器中。因此总体上来说，Java内存模型和计算机硬件内存架构是一个相互交叉的关系，是一种抽象概念划分和真实物理硬件的交叉。（参考：http://tutorials.jenkov.com/java-concurrency/java-memory-model.html）

<img src="jmm2cpu.png">

### JMM的三个基本概念

#### 原子性

原子性指的是一个操作是不可中断的，即使是在多线程环境下，一个操作一旦开始就不会被其他线程影响。

#### 有序性

在计算机执行程序的时候，为了提高性能，编译器和处理器常常会对指令进行重排序。

- 编译器优化重排序

编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序

- 指令并行的重排序

现代处理器采用了指令级别的并行技术来将多条指令并行执行，如果不存在数据的依赖性，处理器可以改变语句对应的机器执行的执行顺序

- 内存系统的重排序

由于处理器使用缓存和读写缓存冲区，这使得加载(load)和存储(store)操作看上去可能是在乱序执行，因为三级缓存的存在，导致内存与缓存的数据同步存在时间差。

其中编译器优化的重排属于编译期重排，指令并行的重排和内存系统的重排属于处理器重排，在多线程环境中，这些重排优化可能会导致程序出现内存可见性问题。对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序。对于处理器重排序，JMM的编译器重排序规则会要求Java编译器在生成指令序列时，插入特定类型的内存屏障指令，通过内存屏障来禁止特定类型的处理器重排序。JMM属于语言级别的内存模型，它确保在不同的编译器会不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。

#### 可见性

解释完指令重排序现象之后，可见性就非常容易理解了。可见性指的是当一个线程修改了某个共享变量的值，其他线程是否能够马上得知这个值的修改。

### JMM提供的解决方案

上述三个问题，JMM都有相应的解决方案提供给出程序员使用。如原子性的问题，除了jvm自身提供的对基本数据类型读写操作的原子性之外，对于方法级别或者代码块级别的原子性操作，可以使用synchronized关键字或者可重入锁ReentrantLock来保证程序执行的原子性。而工作内存与主内存同步延迟现象导致的可见性问题，可以使用synchronized关键字或者volatile关键字来解决，这两个关键字都可以使一个线程修改后的变量立即对其他线程可见。对于指令重排序的问题，则可以使用volatile来解决，因为volatile的另外一个作用便是禁止重排序优化。除了靠synchronized和volatile关键字来保证原子性，可见性和有序性之外，JMM内部还定义了一套happens-before原则来保证多线程环境下两个操作的原子性，可见性和有序性。

### volatile的语义

volatile是Java虚拟机提供的轻量级同步机制，其两个作用如下：

- 保证被volatile修饰的共享变量对所有线程总是可见的，也就是当一个线程修改了一个被volatile修饰的共享变量的值，新值总是可以被其他线程立刻得知
- 禁止指令重排序的优化

#### 可见性保证

被volatile修饰的变量，在转变成汇编代码的时候，会多出一个LOCK#前缀的指令，这个指令在多核CPU架构下会引发两件事情

- 将当前处理器缓存行的数据写回到系统内存中
- 这个写回的操作会使在其他CPU中缓存了该内存地址的数据实效

所以我们不难发现，volatile的底层实现其实就是借助了CPU的缓存一致性协议。后续众多的多线程并发解决方案都是通过volatile+cas原子操作来实现的。

#### 禁止指令重排序

volatile关键字另一个作用就是禁止指令重排优化，从而避免多线程环境下程序出现乱序执行的现象，具体如何禁止的，其实是在转换成汇编代码的时候，在volatile变量的前后根据一些条件来插入特定的内存屏障，来告诉编译器和处理器，这些指令我不需要重排序，这里就不再详细展开了。

#### volatile原子性

对于单个volatile变量的读写具有原子性，但类似于volatile++这种复合操作则不具备原子性(i++这种操作转换成汇编并不是一条指令就能完成的)

